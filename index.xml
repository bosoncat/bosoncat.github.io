<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Somewhere</title>
    <link>/</link>
    <description>Recent content in Home on Somewhere</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Aug 2020 13:18:28 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>My Journey with LLVM (Final Evaluation)</title>
      <link>/archives/my-journey-with-llvm-iii/</link>
      <pubDate>Fri, 28 Aug 2020 13:18:28 +0800</pubDate>
      
      <guid>/archives/my-journey-with-llvm-iii/</guid>
      <description>&lt;p&gt;My GSoC comes to an end and this is a report of my work during the last 3 months. My project is adding DWARF support to &lt;code&gt;yaml2obj&lt;/code&gt;, especially &lt;code&gt;yaml2elf&lt;/code&gt;. The original proposal is &lt;a href=&#34;https://docs.google.com/document/d/13wNr4JbXtzaOly-UsFt7vxI3LKXzik_lVU58ICqslWM/edit?usp=sharing&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SjLj (setjmp/longjmp) 一次错误的使用</title>
      <link>/archives/bad-practice-on-sjlj/</link>
      <pubDate>Sat, 15 Jun 2019 17:28:14 +0800</pubDate>
      
      <guid>/archives/bad-practice-on-sjlj/</guid>
      <description>&lt;p&gt;前几天在为一个关于 LLVM IR 的&lt;a href=&#34;https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/&#34;&gt;教程&lt;/a&gt; 升级语法的时候，发现教程中使用 &lt;code&gt;SjLj&lt;/code&gt; 的地方有点小问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>进程同步的几个小问题</title>
      <link>/archives/process-sync/</link>
      <pubDate>Fri, 19 Oct 2018 15:51:05 +0800</pubDate>
      
      <guid>/archives/process-sync/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;国庆节看了一点点 go, 看到 go channel 比较眼熟，可以当做进程同步中的信号量 &lt;code&gt;(semaphore)&lt;/code&gt;，毕竟 go 是本身支持并发的，所以拿他来做这部分作业还是很省事的，下面就简单的用它来模拟一下课本中几个经典的问题 (本文可能会一点一点的更新，也欢迎大家补充~)，所有代码可以在 &lt;a href=&#34;https://github.com/vgxbj/blog-source/tree/master/process-sync&#34;&gt;Github&lt;/a&gt; 找到&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Vivado HLS 初体验</title>
      <link>/archives/first-scratch-on-vivado-hls/</link>
      <pubDate>Tue, 24 Jul 2018 15:16:46 +0000</pubDate>
      
      <guid>/archives/first-scratch-on-vivado-hls/</guid>
      <description>&lt;p&gt;其实很早就知道 Vivado HLS 这个东西了，但是身边人没有人使用它，只知道它是一个可以把 C/C++ 转化成 HDL 的一个软件。直到这个暑假，有幸在上海的 LLVM 社区中国的线下聚会上，有在北京 Xilinx 工作的工程师分享了一些有关 HLS 的底层实现方面的介绍，也很有趣。而刚好在前段时间的&lt;del&gt;划水&lt;/del&gt;实习中，有要用到一丢丢的 HLS，所以记录一下使用心得。下面要使用的样例是来自 &lt;a href=&#34;https://github.com/KastnerRG/pp4fpgas&#34;&gt;pp4fpgas&lt;/a&gt; 中的 Huffman Encoding 章节。源码可以到前面给出的 Github 链接找到。再次推荐一下这本书，从高层到底层的讲解都十分的棒，相见恨晚！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>更好的管理 Vivado 项目</title>
      <link>/archives/manage-vivado-projects/</link>
      <pubDate>Tue, 10 Jul 2018 15:16:46 +0000</pubDate>
      
      <guid>/archives/manage-vivado-projects/</guid>
      <description>&lt;p&gt;最近在划水 FPGA 的一个培训，因为可以兑换学校的实习学分，所以就凑了热闹，不过重新温习这个东西我也有了一点对 Vivado 项目管理的想法，同时也找到了一些有用的东西&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>「node-ngspice」我的ngspice配置</title>
      <link>/archives/node-ngspice/</link>
      <pubDate>Tue, 24 Apr 2018 15:45:21 +0000</pubDate>
      
      <guid>/archives/node-ngspice/</guid>
      <description>&lt;p&gt;这是一个最近花了整整一天写的很草率的项目&amp;hellip;不过肯定会完善的，至于接下来使用什么前端框架，打算敲定&lt;code&gt;vue.js&lt;/code&gt;了&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>正则表达式引擎</title>
      <link>/archives/hregex/</link>
      <pubDate>Fri, 09 Mar 2018 15:16:46 +0000</pubDate>
      
      <guid>/archives/hregex/</guid>
      <description>&lt;p&gt;上学期学了一些编译器前端的知识，接触到了&lt;code&gt;Flex&lt;/code&gt;，&lt;code&gt;Yacc&lt;/code&gt;这类的工具，同时也对正则表达式引擎有了很大的兴趣，于是总想着自己实现一个简单的正则表达式引擎，在这里是对这部分知识的一个总结，因为网上有很多资料总感觉缺头少尾，大多数人第一次读龙书[1]也是有些Hold不住，所以，这里拿一个&lt;code&gt;入门级&lt;/code&gt;的正则引擎作为例子，总结一下这部分知识&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>子集构造法(Subset construction)</title>
      <link>/archives/subset-construction/</link>
      <pubDate>Mon, 26 Feb 2018 14:56:15 +0000</pubDate>
      
      <guid>/archives/subset-construction/</guid>
      <description>&lt;p&gt;子集构造法的一个Haskell实现，源代码虽不算长，但是我不喜欢长篇大论的贴代码，所以还是把自动机这一部分放到了&lt;a href=&#34;https://gist.github.com/vgxbj/1fc42bac7291136bdb5c60eb330466b3&#34;&gt;Gist&lt;/a&gt;，项目地址: &lt;a href=&#34;https://github.com/vgxbj/hregex&#34;&gt;hregex&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OSX下编译STM32程序</title>
      <link>/archives/build-stm32-program-on-macos/</link>
      <pubDate>Sat, 09 Sep 2017 01:25:01 +0000</pubDate>
      
      <guid>/archives/build-stm32-program-on-macos/</guid>
      <description>&lt;p&gt;大二的这个暑假，被同学拉着去参加了电设，由于比赛用到了&lt;code&gt;STM32&lt;/code&gt;来作为处理器，所以就需要折腾一下&lt;code&gt;STM32&lt;/code&gt;。由于我算半个果粉，所以免不了要去折(zhuang)腾(B)。大家都知道32这类的单片机的开发流程都是利用&lt;code&gt;C&lt;/code&gt;或&lt;code&gt;C++&lt;/code&gt;写成代码后，利用工具编译成32能够识别的二进制或16进制码写到32的&lt;code&gt;Flash&lt;/code&gt;中。那么&lt;code&gt;windows&lt;/code&gt;下能完成的流程，&lt;code&gt;OS X&lt;/code&gt;下也一定能完成,嘻嘻。简述一下我们所需要的工具或者软件: -)&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>